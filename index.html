<!DOCTYPE html><html class="default" lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>queueable</title><meta name="description" content="Documentation for queueable"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script defer src="assets/main.js"></script><script async src="assets/search.js" id="tsd-search-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os"</script><header class="tsd-page-toolbar">
<div class="tsd-toolbar-contents container">
<div class="table-cell" id="tsd-search" data-base=".">
<div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M15.7824 13.833L12.6666 10.7177C12.5259 10.5771 12.3353 10.499 12.1353 10.499H11.6259C12.4884 9.39596 13.001 8.00859 13.001 6.49937C13.001 2.90909 10.0914 0 6.50048 0C2.90959 0 0 2.90909 0 6.49937C0 10.0896 2.90959 12.9987 6.50048 12.9987C8.00996 12.9987 9.39756 12.4863 10.5008 11.6239V12.1332C10.5008 12.3332 10.5789 12.5238 10.7195 12.6644L13.8354 15.7797C14.1292 16.0734 14.6042 16.0734 14.8948 15.7797L15.7793 14.8954C16.0731 14.6017 16.0731 14.1267 15.7824 13.833ZM6.50048 10.499C4.29094 10.499 2.50018 8.71165 2.50018 6.49937C2.50018 4.29021 4.28781 2.49976 6.50048 2.49976C8.71001 2.49976 10.5008 4.28708 10.5008 6.49937C10.5008 8.70852 8.71314 10.499 6.50048 10.499Z" fill="var(--color-text)"></path></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div>
<div class="field">
<div id="tsd-toolbar-links"></div></div>
<ul class="results">
<li class="state loading">Preparing search index...</li>
<li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">queueable</a></div>
<div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><rect x="1" y="3" width="14" height="2" fill="var(--color-text)"></rect><rect x="1" y="7" width="14" height="2" fill="var(--color-text)"></rect><rect x="1" y="11" width="14" height="2" fill="var(--color-text)"></rect></svg></a></div></div></header>
<div class="container container-main">
<div class="col-content">
<div class="tsd-page-title">
<h2>queueable</h2></div>
<div class="tsd-panel tsd-typography"><h1 align="center"><a href="https://github.com/slikts/queueable"><img src="https://raw.githubusercontent.com/slikts/queueable/master/logo.svg?sanitize=true" width="450" height="190" alt="Queueable"></a></h1>

<p align="center"><a href="https://github.com/slikts/queueable"><img src="https://img.shields.io/github/license/slikts/queueable.svg" alt="License"></a>
<a href="https://travis-ci.org/slikts/queueable"><img src="https://img.shields.io/travis/slikts/queueable/master.svg" alt="Build Status"></a>
<a href="https://coveralls.io/github/slikts/queueable?branch=master"><img src="https://coveralls.io/repos/github/slikts/queueable/badge.svg?branch=master" alt="Coverage Status"></a>
<a href="https://www.npmjs.com/package/queueable"><img src="https://img.shields.io/npm/v/queueable.svg" alt="Latest Stable Version"></a>
<a href="https://codeclimate.com/github/slikts/queueable"><img src="https://codeclimate.com/github/slikts/queueable.svg" alt="Code Climate"></a></p>

<p>A library for converting push-based asynchronous streams like node streams or EventTarget to pull-based streams implementing the <a href="http://2ality.com/2016/10/asynchronous-iteration.html">ES2018 asynchronous iteration protocols</a>.</p>
<p>Well-typed, well-tested and <a href="https://bundlephobia.com/result?p=queueable">lightweight</a>.</p>
<a id="md:overview" class="tsd-anchor"></a><h2><a href="#md:overview">Overview</a></h2><p>Asynchronous iteration is a new native feature of JavaScript for modeling streams of values in time. To give a rough analogy, asynchronous iteration is to event emitters as promises are to callbacks. The problem this library helps to solve is that iterables have a pull-based interface, while sources like event emitters are push-based, and converting between the two kinds of providers involves buffering the difference between pushes and pulls until it can be settled. This library provides push-pull adapters with buffering strategies suitable for different use cases.</p>
<p>Queueable is intended both for library authors and consumers. Library authors can implement a standard streaming interface for interoperability, and consumers can adapt not-yet interoperable sources to leverage tools like <a href="https://github.com/ReactiveX/IxJS#asynciterable">IxJS</a> and a declarative approach to streams.</p>
<a id="md:similarity-to-streams-api-and-node-streams" class="tsd-anchor"></a><h3><a href="#md:similarity-to-streams-api-and-node-streams">Similarity to Streams API and node streams</a></h3><p>Asynchronous iteration together with this library could be seen as a lightweight version of the WHATWG <a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API">Streams API</a>. Specifically, the adapters work like <a href="https://streams.spec.whatwg.org/#ts">identity transform streams</a>. Asynchronous iteration <a href="https://github.com/whatwg/streams/issues/778">has been added</a> to Streams API <code>ReadableStream</code>.</p>
<p>Node streams have <a href="https://nodejs.org/api/stream.html#stream_readable_symbol_asynciterator">already implemented</a> asynchronous iteration for reading.</p>
<p>The use-case for this library, given that there are more standard alternatives, is based on its small size. Older browsers and node versions don&#39;t implement the newer APIs, and including a polyfill for a large API can be prohibitive.</p>
<a id="md:similarity-to-csp-channels" class="tsd-anchor"></a><h3><a href="#md:similarity-to-csp-channels">Similarity to CSP channels</a></h3><p><a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating sequential processes</a> (CSP) is a concurrency model used in Go goroutines and <a href="https://clojure.org/news/2013/06/28/clojure-clore-async-channels">Clojure&#39;s core.async</a> that is based on message passing via channels, and it&#39;s been possible to express this model in JavaScript with ES6 generators, as shown by <a href="https://github.com/ubolonton/js-csp">js-csp</a>. Asynchronous iteration brings JavaScript closer to having first-class syntactical support of channels, as can be seen in this <a href="https://codepen.io/slikts/pen/yRPgQE?editors=0012">demonstration of ping-pong</a> adapted from Go and js-csp using Queuable.</p>
<a id="md:use-cases" class="tsd-anchor"></a><h3><a href="#md:use-cases">Use cases</a></h3><p>Sources of asynchronous data that are pull-based (are backpressurable; allow the consumer to control the rate at which it receives data) are trivial to adapt to asynchronous iterators using asynchronous generator functions. Such sources include event emitters that can be paused and resumed, and callback functions that are fired a single time, and functions that return promises.</p>
<p>Converting pull-based sources to asynchronous iterables is still made easier by the <code>wrapRequest</code> helper method provided by this library. For a demonstration, see <code>requestAnimationFrame</code> example (also showing IxJS usage) and implementing an example interval.</p>
<p>Sources that are not backpressurable can only be sampled by subscribing to them or unsubscribing, and examples of such sources are user events like mouse clicks. Users can&#39;t be paused, so this library takes care of buffering the events they generate until requested by the consumer. See mouse events demonstration.</p>
<!--### How it works

generate-->

<a id="md:asynchronous-iteration" class="tsd-anchor"></a><h3><a href="#md:asynchronous-iteration">Asynchronous iteration</a></h3><p>See slides about <a href="https://docs.google.com/presentation/d/1r2V1sLG8JSSk8txiLh4wfTkom-BoOsk52FgPBy8o3RM">Why Asynchronous Iterators Matter</a> for a more general introduction to the topic.</p>
<a id="md:installation" class="tsd-anchor"></a><h2><a href="#md:installation">Installation</a></h2><pre><code class="language-sh"><span class="hl-0">npm</span><span class="hl-1"> </span><span class="hl-2">install</span><span class="hl-1"> </span><span class="hl-3">--save</span><span class="hl-1"> </span><span class="hl-2">queueable</span>
</code><button>Copy</button></pre>
<pre><code class="language-sh"><span class="hl-0">yarn</span><span class="hl-1"> </span><span class="hl-2">add</span><span class="hl-1"> </span><span class="hl-2">queueable</span>
</code><button>Copy</button></pre>
<a id="md:cdn" class="tsd-anchor"></a><h3><a href="#md:cdn">CDN</a></h3><p><a href="https://unpkg.com/queueable/dist/queueable.umd.js">https://unpkg.com/queueable/dist/queueable.umd.js</a></p>
<a id="md:adapters" class="tsd-anchor"></a><h2><a href="#md:adapters">Adapters</a></h2><a id="md:channel" class="tsd-anchor"></a><h3><a href="#md:channel"><a href="https://slikts.github.io/queueable/classes/Channel.html"><code>Channel</code></a></a></h3><p>Push-pull adapter backed by unbounded linked list queues (to avoid array reindexing) with optional circular buffering.</p>
<p>Circular buffering works like a safety valve by discarding the oldest item in the queue when the limit is reached.</p>
<a id="md:methods" class="tsd-anchor"></a><h4><a href="#md:methods">Methods</a></h4><ul>
<li><code>static constructor(pushLimit = 0, pullLimit = 0)</code></li>
<li><code>static fromDom(eventType, target[, options])</code></li>
<li><code>static fromEmitter(eventType, emitter)</code></li>
<li><code>push(value, [done])</code>
Push a value to the queue; returns a promise that resolves when the value is pulled.</li>
<li><code>wrap([onReturn])</code>
Return an iterable iterator with only the standard methods.</li>
</ul>
<a id="md:examples" class="tsd-anchor"></a><h4><a href="#md:examples">Examples</a></h4><a id="md:implementing-an-asynchronous-iterable-iterator-pushing-values-to-it-and-then-consuming-with-for-await-of" class="tsd-anchor"></a><h5><a href="#md:implementing-an-asynchronous-iterable-iterator-pushing-values-to-it-and-then-consuming-with-for-await-of">Implementing an asynchronous iterable iterator, pushing values to it and then consuming with <code>for-await-of</code></a></h5><pre><code class="language-js"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Channel</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;queueable&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">channel</span><span class="hl-1"> = </span><span class="hl-3">new</span><span class="hl-1"> </span><span class="hl-0">Channel</span><span class="hl-1">();</span><br/><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">push</span><span class="hl-1">(</span><span class="hl-7">1</span><span class="hl-1">);</span><br/><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">push</span><span class="hl-1">(</span><span class="hl-7">2</span><span class="hl-1">);</span><br/><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">push</span><span class="hl-1">(</span><span class="hl-7">3</span><span class="hl-1">);</span><br/><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">push</span><span class="hl-1">(</span><span class="hl-7">4</span><span class="hl-1">, </span><span class="hl-3">true</span><span class="hl-1">); </span><span class="hl-8">// the second argument closes the iterator when its turn is reached</span><br/><br/><span class="hl-8">// for-await-of uses the async iterable protocol to consume the queue sequentially</span><br/><span class="hl-4">for</span><span class="hl-1"> </span><span class="hl-4">await</span><span class="hl-1"> (</span><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">n</span><span class="hl-1"> </span><span class="hl-3">of</span><span class="hl-1"> </span><span class="hl-5">channel</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-5">n</span><span class="hl-1">); </span><span class="hl-8">// logs 1, 2, 3</span><br/><span class="hl-1">  </span><span class="hl-8">// doesn&#39;t log 4, because for-await-of ignores the value of a closing result</span><br/><span class="hl-1">}</span><br/><span class="hl-8">// the loop ends after it reaches a result where the iterator is closed</span>
</code><button>Copy</button></pre>
<a id="md:pulling-results-and-waiting-for-values-to-be-pushed" class="tsd-anchor"></a><h5><a href="#md:pulling-results-and-waiting-for-values-to-be-pushed">Pulling results and waiting for values to be pushed</a></h5><pre><code class="language-js"><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">channel</span><span class="hl-1"> = </span><span class="hl-3">new</span><span class="hl-1"> </span><span class="hl-0">Channel</span><span class="hl-1">();</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">result</span><span class="hl-1"> = </span><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">(); </span><span class="hl-8">// a promise of an iterator result</span><br/><span class="hl-5">result</span><span class="hl-1">.</span><span class="hl-0">then</span><span class="hl-1">(({ </span><span class="hl-5">value</span><span class="hl-1"> }) </span><span class="hl-3">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-5">value</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">push</span><span class="hl-1">(</span><span class="hl-2">&#39;hello&#39;</span><span class="hl-1">); </span><span class="hl-8">// &quot;hello&quot; is logged in the next microtick</span>
</code><button>Copy</button></pre>
<a id="md:hiding-the-adapter-methods-from-consumers-with-wrap" class="tsd-anchor"></a><h5><a href="#md:hiding-the-adapter-methods-from-consumers-with-wrap">Hiding the adapter methods from consumers with <code>wrap()</code></a></h5><p>The iterables should be one-way for end-users, meaning that the consumer should only be able to request values, not push them, because the iterables could be shared. The <code>wrap([onReturn])</code> method returns an object with only the standard iterable methods.</p>
<p>This example adapts an EventTarget in the same way as the <code>fromDom()</code> method.</p>
<pre><code class="language-js"><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">channel</span><span class="hl-1"> = </span><span class="hl-3">new</span><span class="hl-1"> </span><span class="hl-0">Channel</span><span class="hl-1">();</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-0">listener</span><span class="hl-1"> = (</span><span class="hl-5">event</span><span class="hl-1">) </span><span class="hl-3">=&gt;</span><span class="hl-1"> </span><span class="hl-3">void</span><span class="hl-1"> </span><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">push</span><span class="hl-1">(</span><span class="hl-5">event</span><span class="hl-1">);</span><br/><span class="hl-5">eventTarget</span><span class="hl-1">.</span><span class="hl-0">addEventListener</span><span class="hl-1">(</span><span class="hl-2">&#39;click&#39;</span><span class="hl-1">, </span><span class="hl-5">listener</span><span class="hl-1">);</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">clickIterable</span><span class="hl-1"> = </span><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">wrap</span><span class="hl-1">(() </span><span class="hl-3">=&gt;</span><span class="hl-1"> </span><span class="hl-5">eventTarget</span><span class="hl-1">.</span><span class="hl-0">removeEventListener</span><span class="hl-1">(</span><span class="hl-5">type</span><span class="hl-1">, </span><span class="hl-5">listener</span><span class="hl-1">));</span><br/><span class="hl-5">clickIterable</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">(); </span><span class="hl-8">// -&gt; a promise of the next click event</span><br/><span class="hl-5">clickIterable</span><span class="hl-1">.</span><span class="hl-0">return</span><span class="hl-1">(); </span><span class="hl-8">// closes the iterable</span>
</code><button>Copy</button></pre>
<a id="md:tracking-when-pushed-values-are-pulled" class="tsd-anchor"></a><h5><a href="#md:tracking-when-pushed-values-are-pulled">Tracking when pushed values are pulled</a></h5><p>The <code>push()</code> methods for the adapters return the same promise as the <code>next()</code> methods for the iterators, so it&#39;s possible for the provider to track when the pushed value is used to resolve a pull.</p>
<pre><code class="language-js"><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">channel</span><span class="hl-1"> = </span><span class="hl-3">new</span><span class="hl-1"> </span><span class="hl-0">Channel</span><span class="hl-1">();</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">tracking</span><span class="hl-1"> = </span><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">push</span><span class="hl-1">(</span><span class="hl-7">123</span><span class="hl-1">);</span><br/><span class="hl-5">tracking</span><span class="hl-1">.</span><span class="hl-0">then</span><span class="hl-1">(() </span><span class="hl-3">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">&#39;value was pulled&#39;</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">result</span><span class="hl-1"> = </span><span class="hl-5">channel</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">(); </span><span class="hl-8">// pulling the next result resolves `tracking` promise</span><br/><span class="hl-5">result</span><span class="hl-1"> === </span><span class="hl-5">tracking</span><span class="hl-1">; </span><span class="hl-8">// -&gt; true</span><br/><span class="hl-1">(</span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">result</span><span class="hl-1">) === (</span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">tracking</span><span class="hl-1">); </span><span class="hl-8">// -&gt; true</span>
</code><button>Copy</button></pre>
<a id="md:lastresult" class="tsd-anchor"></a><h3><a href="#md:lastresult"><a href="https://slikts.github.io/queueable/classes/LastResult.html"><code>LastResult</code></a></a></h3><p>An adapter that only buffers the last value pushed and caches and broadcasts it (pulling a value doesn&#39;t dequeue it). It&#39;s suitable for use cases where skipping results is allowed.</p>
<a id="md:methods-1" class="tsd-anchor"></a><h4><a href="#md:methods-1">Methods</a></h4><ul>
<li><code>static constructor()</code></li>
<li><code>static fromDom(eventType, target[, options])</code></li>
<li><code>static fromEmitter(eventType, emitter)</code></li>
<li><code>push(value)</code>
Overwrite the previously pushed value.</li>
<li><code>wrap([onReturn])</code>
Return an iterable iterator with only the standard methods.</li>
</ul>
<a id="md:examples-1" class="tsd-anchor"></a><h4><a href="#md:examples-1">Examples</a></h4><a id="md:converting-mouse-move-events-into-a-stream" class="tsd-anchor"></a><h5><a href="#md:converting-mouse-move-events-into-a-stream">Converting mouse move events into a stream</a></h5><pre><code class="language-js"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">LastResult</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;queueable&#39;</span><span class="hl-1">;</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">moveIterable</span><span class="hl-1"> = </span><span class="hl-5">LastResult</span><span class="hl-1">.</span><span class="hl-0">fromDom</span><span class="hl-1">(</span><span class="hl-2">&#39;click&#39;</span><span class="hl-1">, </span><span class="hl-5">eventTarget</span><span class="hl-1">);</span><br/><span class="hl-4">for</span><span class="hl-1"> </span><span class="hl-4">await</span><span class="hl-1"> (</span><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">moveEvent</span><span class="hl-1"> </span><span class="hl-3">of</span><span class="hl-1"> </span><span class="hl-5">moveIterable</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-5">moveEvent</span><span class="hl-1">); </span><span class="hl-8">// logs MouseEvent objects each time the mouse is clicked</span><br/><span class="hl-1">}</span><br/><span class="hl-8">// the event listener can be removed and stream closed with .return()</span><br/><span class="hl-5">moveIterable</span><span class="hl-1">.</span><span class="hl-0">return</span><span class="hl-1">();</span>
</code><button>Copy</button></pre>
<a id="md:wraprequestrequest-onreturn" class="tsd-anchor"></a><h3><a href="#md:wraprequestrequest-onreturn"><code>wrapRequest(request[, onReturn])</code></a></h3><p>The <code>wrapRequest()</code> method converts singular callbacks to an asynchronous iterable and provides an optional hook for cleanup when the <code>return()</code> is called.</p>
<a id="md:examples-2" class="tsd-anchor"></a><h4><a href="#md:examples-2">Examples</a></h4><a id="md:adapting-requestanimationframe" class="tsd-anchor"></a><h5><a href="#md:adapting-requestanimationframe">Adapting <code>requestAnimationFrame()</code></a></h5><pre><code class="language-js"><span class="hl-3">const</span><span class="hl-1"> { </span><span class="hl-6">wrapRequest</span><span class="hl-1"> } = </span><span class="hl-2">&#39;queueable&#39;</span><span class="hl-1">;</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">frames</span><span class="hl-1"> = </span><span class="hl-0">wrapRequest</span><span class="hl-1">(</span><span class="hl-5">window</span><span class="hl-1">.</span><span class="hl-5">requestAnimationFrame</span><span class="hl-1">, </span><span class="hl-5">window</span><span class="hl-1">.</span><span class="hl-5">cancelAnimationFrame</span><span class="hl-1">);</span><br/><span class="hl-4">for</span><span class="hl-1"> </span><span class="hl-4">await</span><span class="hl-1"> (</span><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">timestamp</span><span class="hl-1"> </span><span class="hl-3">of</span><span class="hl-1"> </span><span class="hl-5">frames</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-5">timestamp</span><span class="hl-1">); </span><span class="hl-8">// logs frame timestamps sequentially</span><br/><span class="hl-1">}</span>
</code><button>Copy</button></pre>
<a id="md:creating-an-iterable-interval-with-settimeout" class="tsd-anchor"></a><h5><a href="#md:creating-an-iterable-interval-with-settimeout">Creating an iterable interval with <code>setTimeout()</code></a></h5><pre><code class="language-js"><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-0">makeInterval</span><span class="hl-1"> = (</span><span class="hl-5">delay</span><span class="hl-1">) </span><span class="hl-3">=&gt;</span><br/><span class="hl-1">  </span><span class="hl-0">wrapRequest</span><span class="hl-1">((</span><span class="hl-5">callback</span><span class="hl-1">) </span><span class="hl-3">=&gt;</span><span class="hl-1"> </span><span class="hl-5">window</span><span class="hl-1">.</span><span class="hl-0">setTimeout</span><span class="hl-1">(</span><span class="hl-5">callback</span><span class="hl-1">, </span><span class="hl-5">delay</span><span class="hl-1">), </span><span class="hl-5">window</span><span class="hl-1">.</span><span class="hl-5">clearTimeout</span><span class="hl-1">);</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">interval</span><span class="hl-1"> = </span><span class="hl-0">makeInterval</span><span class="hl-1">(</span><span class="hl-7">100</span><span class="hl-1">); </span><span class="hl-8">// creates the interval but does nothing until .next() is invoked</span><br/><span class="hl-3">let</span><span class="hl-1"> </span><span class="hl-5">i</span><span class="hl-1"> = </span><span class="hl-7">0</span><span class="hl-1">;</span><br/><span class="hl-4">for</span><span class="hl-1"> </span><span class="hl-4">await</span><span class="hl-1"> (</span><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">_</span><span class="hl-1"> </span><span class="hl-3">of</span><span class="hl-1"> </span><span class="hl-5">interval</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-5">i</span><span class="hl-1"> += </span><span class="hl-7">1</span><span class="hl-1">;</span><br/><span class="hl-1">  </span><span class="hl-4">if</span><span class="hl-1"> (</span><span class="hl-5">i</span><span class="hl-1"> === </span><span class="hl-7">10</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-5">interval</span><span class="hl-1">.</span><span class="hl-0">return</span><span class="hl-1">(); </span><span class="hl-8">// stops the interval</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">}</span>
</code><button>Copy</button></pre>
<a id="md:multicast" class="tsd-anchor"></a><h3><a href="#md:multicast"><a href="https://slikts.github.io/queueable/classes/multicast.html"><code>Multicast</code></a></a></h3><p>The same concept as <code>Subject</code> in observables; allows having zero or more subscribers that each receive the pushed values. The pushed values are discarded if there are no subscribers. Uses the <code>Channel</code> adapters internally.</p>
<pre><code class="language-js"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Multicast</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;queueable&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">queue</span><span class="hl-1"> = </span><span class="hl-3">new</span><span class="hl-1"> </span><span class="hl-0">Multicast</span><span class="hl-1">();</span><br/><span class="hl-8">// subscribe two iterators to receive results</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">subscriberA</span><span class="hl-1"> = </span><span class="hl-5">queue</span><span class="hl-1">[</span><span class="hl-5">Symbol</span><span class="hl-1">.</span><span class="hl-5">asyncIterator</span><span class="hl-1">]();</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">subscriberB</span><span class="hl-1"> = </span><span class="hl-5">queue</span><span class="hl-1">[</span><span class="hl-5">Symbol</span><span class="hl-1">.</span><span class="hl-5">asyncIterator</span><span class="hl-1">]();</span><br/><span class="hl-5">queue</span><span class="hl-1">.</span><span class="hl-0">push</span><span class="hl-1">(</span><span class="hl-7">123</span><span class="hl-1">);</span><br/><span class="hl-3">const</span><span class="hl-1"> </span><span class="hl-6">results</span><span class="hl-1"> = </span><span class="hl-9">Promise</span><span class="hl-1">.</span><span class="hl-0">all</span><span class="hl-1">([</span><span class="hl-5">subscriberA</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">(), </span><span class="hl-5">subscriberB</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">()]);</span><br/><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">results</span><span class="hl-1">); </span><span class="hl-8">// logs [{ value: 123, done: false }, { value: 123, done: false }]</span>
</code><button>Copy</button></pre>
<a id="md:types" class="tsd-anchor"></a><h2><a href="#md:types">Types</a></h2><p>To make TypeScript know about the asnyc iterable types (<code>AsyncIterable&lt;T&gt;</code>, <code>AsyncIterator&lt;T&gt;</code>, <code>AsyncIterableiterator&lt;T&gt;</code>), the TypeScript <code>--lib</code> <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">compiler option</a> should include <code>&quot;esnext.asynciterable&quot;</code> or <code>&quot;esnext&quot;</code>.</p>
<a id="md:alternatives" class="tsd-anchor"></a><h2><a href="#md:alternatives">Alternatives</a></h2><ul>
<li><a href="https://github.com/withspectrum/callback-to-async-iterator">callback-to-async-iterator</a></li>
<li><a href="https://github.com/rolftimmermans/event-iterator">event-iterator</a></li>
<li><a href="https://repeater.js.org/">Repeater.js</a></li>
<li><a href="https://github.com/benlesh/rxjs-for-await">rxjs-for-await</a></li>
</ul>
<a id="md:tools-for-async-iteration" class="tsd-anchor"></a><h2><a href="#md:tools-for-async-iteration">Tools for async iteration</a></h2><ul>
<li><a href="https://github.com/ReactiveX/IxJS#asynciterable">IxJS</a> – supports various combinators for async iterables</li>
<li><a href="https://github.com/slikts/symbola">Symbola</a> – protocol extension based combinators for async iterables</li>
<li><a href="https://github.com/jamiemccrindle/axax">Axax</a> – async iteration helpers</li>
<li><a href="https://github.com/leebyron/iterall">iterall</a> – iteration utilities</li>
<li><a href="https://github.com/sithmel/iter-tools">iter-tools</a> – iteration helpers</li>
</ul>
</div></div>
<div class="col-sidebar">
<div class="page-menu">
<div class="tsd-navigation settings">
<details class="tsd-index-accordion"><summary class="tsd-accordion-summary">
<h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4.93896 8.531L12 15.591L19.061 8.531L16.939 6.409L12 11.349L7.06098 6.409L4.93896 8.531Z" fill="var(--color-text)" id="icon-chevronDown"></path></svg>Settings</h3></summary>
<div class="tsd-accordion-details">
<div class="tsd-filter-visibility">
<h4 class="uppercase">Member Visibility</h4><form>
<ul id="tsd-filter-options">
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li>
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-private" name="private"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Private</span></label></li>
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li>
<li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></form></div>
<div class="tsd-theme-toggle">
<h4 class="uppercase">Theme</h4><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div>
<details open class="tsd-index-accordion tsd-page-navigation"><summary class="tsd-accordion-summary">
<h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="#icon-chevronDown"></use></svg>On This Page</h3></summary>
<div class="tsd-accordion-details">
<ul>
<li>
<ul>
<li><a href="#md:overview"><span>Overview</span></a></li>
<li>
<ul>
<li><a href="#md:similarity-to-streams-api-and-node-streams"><span>Similarity to <wbr/>Streams API and node streams</span></a></li>
<li>
<ul>
<li><a href="#md:similarity-to-csp-channels"><span>Similarity to CSP channels</span></a></li>
<li><a href="#md:use-cases"><span>Use cases</span></a></li>
<li><a href="#md:asynchronous-iteration"><span>Asynchronous iteration</span></a></li></ul></li>
<li><a href="#md:installation"><span>Installation</span></a></li>
<li>
<ul>
<li><a href="#md:cdn"><span>CDN</span></a></li></ul></li>
<li><a href="#md:adapters"><span>Adapters</span></a></li>
<li>
<ul>
<li><a href="#md:channel"><span>Channel</span></a></li>
<li>
<ul>
<li><a href="#md:methods"><span>Methods</span></a></li>
<li><a href="#md:examples"><span>Examples</span></a></li>
<li>
<ul>
<li><a href="#md:implementing-an-asynchronous-iterable-iterator-pushing-values-to-it-and-then-consuming-with-for-await-of"><span>Implementing an asynchronous iterable iterator, pushing values to it and then consuming with for-<wbr/>await-<wbr/>of</span></a></li>
<li><a href="#md:pulling-results-and-waiting-for-values-to-be-pushed"><span>Pulling results and waiting for values to be pushed</span></a></li>
<li><a href="#md:hiding-the-adapter-methods-from-consumers-with-wrap"><span>Hiding the adapter methods from consumers with wrap()</span></a></li>
<li><a href="#md:tracking-when-pushed-values-are-pulled"><span>Tracking when pushed values are pulled</span></a></li></ul></li></ul></li>
<li><a href="#md:lastresult"><span>Last<wbr/>Result</span></a></li>
<li>
<ul>
<li><a href="#md:methods-1"><span>Methods</span></a></li>
<li><a href="#md:examples-1"><span>Examples</span></a></li>
<li>
<ul>
<li><a href="#md:converting-mouse-move-events-into-a-stream"><span>Converting mouse move events into a stream</span></a></li></ul></li></ul></li>
<li><a href="#md:wraprequestrequest-onreturn"><span>wrap<wbr/>Request(request[, on<wbr/>Return])</span></a></li>
<li>
<ul>
<li><a href="#md:examples-2"><span>Examples</span></a></li>
<li>
<ul>
<li><a href="#md:adapting-requestanimationframe"><span>Adapting request<wbr/>Animation<wbr/>Frame()</span></a></li>
<li><a href="#md:creating-an-iterable-interval-with-settimeout"><span>Creating an iterable interval with set<wbr/>Timeout()</span></a></li></ul></li></ul></li>
<li><a href="#md:multicast"><span>Multicast</span></a></li></ul></li>
<li><a href="#md:types"><span>Types</span></a></li>
<li><a href="#md:alternatives"><span>Alternatives</span></a></li>
<li><a href="#md:tools-for-async-iteration"><span>Tools for async iteration</span></a></li></ul></li></ul></li></ul></div></details></div>
<div class="site-menu">
<nav class="tsd-navigation"><a href="modules.html" class="current"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><g id="icon-4"><rect fill="var(--color-icon-background)" stroke="var(--color-ts-namespace)" stroke-width="1.5" x="1" y="1" width="22" height="22" rx="6"></rect><path d="M9.33 16V7.24H10.77L13.446 14.74C13.43 14.54 13.41 14.296 13.386 14.008C13.37 13.712 13.354 13.404 13.338 13.084C13.33 12.756 13.326 12.448 13.326 12.16V7.24H14.37V16H12.93L10.266 8.5C10.282 8.692 10.298 8.936 10.314 9.232C10.33 9.52 10.342 9.828 10.35 10.156C10.366 10.476 10.374 10.784 10.374 11.08V16H9.33Z" fill="var(--color-text)"></path></g></svg><span>queueable</span></a>
<ul class="tsd-small-nested-navigation">
<li><a href="classes/Buffer.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><g id="icon-128"><rect fill="var(--color-icon-background)" stroke="var(--color-ts-class)" stroke-width="1.5" x="1" y="1" width="22" height="22" rx="6"></rect><path d="M11.898 16.1201C11.098 16.1201 10.466 15.8961 10.002 15.4481C9.53803 15.0001 9.30603 14.3841 9.30603 13.6001V9.64012C9.30603 8.85612 9.53803 8.24012 10.002 7.79212C10.466 7.34412 11.098 7.12012 11.898 7.12012C12.682 7.12012 13.306 7.34812 13.77 7.80412C14.234 8.25212 14.466 8.86412 14.466 9.64012H13.386C13.386 9.14412 13.254 8.76412 12.99 8.50012C12.734 8.22812 12.37 8.09212 11.898 8.09212C11.426 8.09212 11.054 8.22412 10.782 8.48812C10.518 8.75212 10.386 9.13212 10.386 9.62812V13.6001C10.386 14.0961 10.518 14.4801 10.782 14.7521C11.054 15.0161 11.426 15.1481 11.898 15.1481C12.37 15.1481 12.734 15.0161 12.99 14.7521C13.254 14.4801 13.386 14.0961 13.386 13.6001H14.466C14.466 14.3761 14.234 14.9921 13.77 15.4481C13.306 15.8961 12.682 16.1201 11.898 16.1201Z" fill="var(--color-text)"></path></g></svg><span>Buffer</span></a></li>
<li><a href="classes/Channel.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-128"></use></svg><span>Channel</span></a></li>
<li><a href="classes/Deferred.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-128"></use></svg><span>Deferred</span></a></li>
<li><a href="classes/LastResult.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-128"></use></svg><span>Last<wbr/>Result</span></a></li>
<li><a href="classes/Multicast.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-128"></use></svg><span>Multicast</span></a></li>
<li><a href="interfaces/PushAdapter.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><g id="icon-256"><rect fill="var(--color-icon-background)" stroke="var(--color-ts-interface)" stroke-width="1.5" x="1" y="1" width="22" height="22" rx="6"></rect><path d="M9.51 16V15.016H11.298V8.224H9.51V7.24H14.19V8.224H12.402V15.016H14.19V16H9.51Z" fill="var(--color-text)"></path></g></svg><span>Push<wbr/>Adapter</span></a></li>
<li><a href="interfaces/Unpushed.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-256"></use></svg><span>Unpushed</span></a></li>
<li><a href="interfaces/WrappedBalancer.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-256"></use></svg><span>Wrapped<wbr/>Balancer</span></a></li>
<li><a href="types/EventMap.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><g id="icon-4194304"><rect fill="var(--color-icon-background)" stroke="var(--color-ts-type-alias)" stroke-width="1.5" x="1" y="1" width="22" height="22" rx="6"></rect><path d="M11.31 16V8.224H8.91V7.24H14.79V8.224H12.39V16H11.31Z" fill="var(--color-text)"></path></g></svg><span>Event<wbr/>Map</span></a></li>
<li><a href="types/Listener.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-4194304"></use></svg><span>Listener</span></a></li>
<li><a href="types/Target.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-4194304"></use></svg><span>Target</span></a></li>
<li><a href="functions/fromDom.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><g id="icon-64"><rect fill="var(--color-icon-background)" stroke="var(--color-ts-function)" stroke-width="1.5" x="1" y="1" width="22" height="22" rx="6"></rect><path d="M9.39 16V7.24H14.55V8.224H10.446V11.128H14.238V12.112H10.47V16H9.39Z" fill="var(--color-text)"></path></g></svg><span>from<wbr/>Dom</span></a></li>
<li><a href="functions/fromEmitter.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="#icon-64"></use></svg><span>from<wbr/>Emitter</span></a></li></ul></nav></div></div></div>
<div class="tsd-generator">
<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div>
<div class="overlay"></div></body></html>